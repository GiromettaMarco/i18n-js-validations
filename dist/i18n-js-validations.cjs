"use strict";var m=Object.defineProperty;var g=(n,r,e)=>r in n?m(n,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[r]=e;var l=(n,r,e)=>g(n,typeof r!="symbol"?r+"":r,e);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});class d{constructor(r,e){l(this,"key");l(this,"parameters");this.key=r,e&&(this.parameters=e)}}class c{constructor(r,e,s){l(this,"rule");l(this,"passed");l(this,"message");this.rule=r,this.passed=e,s!==void 0&&(this.message=s)}}class h{constructor(){l(this,"strings")}reply(r="fail",e,s,t){const a=r==="success",i=e!==void 0&&e!=="",u=this.getString(r,i,s);if(u===void 0)return new c(this.name,a);const o=i?{label:e,...t}:t;return new c(this.name,a,new d(u,o))}replySuccess(r,e,s){return this.reply("success",r,e,s)}replyFail(r,e,s){return this.reply("fail",r,e,s)}getString(r="fail",e=!1,s){var a,i;const t=e?"withLabel":"withoutLabel";if((i=(a=this.strings)==null?void 0:a[r])!=null&&i[t])return s&&this.strings[r][t][s]?this.strings[r][t][s]:this.strings[r][t].default}}class f{constructor(){l(this,"replies",[]);l(this,"hasErrors",!1);l(this,"errorMessages",[])}clear(){this.hasErrors=!1,this.replies=[],this.errorMessages=[]}push(r){return r.passed||(this.hasErrors=!0,r.message!==void 0&&this.errorMessages.push(r.message)),this.replies.push(r)}}class b extends h{constructor(){super(...arguments);l(this,"name","alpha");l(this,"strings",{fail:{withLabel:{default:"The field :label can contain only alphabetic characters","{}":"The field {label} can contain only alphabetic characters"},withoutLabel:{default:"This field can contain only alphabetic characters"}}})}validate(e,s,t,a){return(s.ascii?/^[a-zA-Z]+$/u:/^[\p{L}\p{M}]+$/u).test(e)?this.replySuccess(t,a):this.replyFail(t,a)}callback(e,s,t,a){if(typeof e!="string")return this.replyFail(t,a);const i=s[0]==="ascii";return this.validate(e,{ascii:i},t,a)}}class p extends h{constructor(){super(...arguments);l(this,"name","alpha_dash");l(this,"strings",{fail:{withLabel:{default:"The field :label can contain only alpha-numeric characters, dashes and underscores","{}":"The field {label} can contain only alpha-numeric characters, dashes and underscores"},withoutLabel:{default:"This field can contain only alpha-numeric characters, dashes and underscores"}}})}validate(e,s,t,a){return(s.ascii?/^[a-zA-Z0-9_-]+$/u:/^[\p{L}\p{M}\p{N}_-]+$/u).test(e)?this.replySuccess(t,a):this.replyFail(t,a)}callback(e,s,t,a){const i=typeof e=="number"?e.toString():e;if(typeof i!="string")return this.replyFail(t,a);const u=s[0]==="ascii";return this.validate(i,{ascii:u},t,a)}}class y extends h{constructor(){super(...arguments);l(this,"name","alpha_num");l(this,"strings",{fail:{withLabel:{default:"The field :label can contain only alpha-numeric characters","{}":"The field {label} can contain only alpha-numeric characters"},withoutLabel:{default:"This field can contain only alpha-numeric characters"}}})}validate(e,s,t,a){return(s.ascii?/^[a-zA-Z0-9]+$/u:/^[\p{L}\p{M}\p{N}]+$/u).test(e)?this.replySuccess(t,a):this.replyFail(t,a)}callback(e,s,t,a){const i=typeof e=="number"?e.toString():e;if(typeof i!="string")return this.replyFail(t,a);const u=s[0]==="ascii";return this.validate(i,{ascii:u},t,a)}}class w extends h{constructor(){super(...arguments);l(this,"name","equal");l(this,"strings",{fail:{withLabel:{default:"The field :label does not match","{}":"The field {label} does not match"},withoutLabel:{default:"This field does not match"}}})}validate(e,s,t,a){for(const i of s.comparison)if(i===e)return this.replySuccess(t,a);return this.replyFail(t,a)}callback(e,s,t,a){if(s[0]===void 0)throw new Error("A comparison value must be provided");const i=typeof e=="string"?e:String(e);return this.validate(i,{comparison:s},t,a)}}class x extends h{constructor(){super(...arguments);l(this,"name","hex_color");l(this,"strings",{fail:{withLabel:{default:"The field :label must be a valid color in hexadecimal format","{}":"The field {label} must be a valid color in hexadecimal format"},withoutLabel:{default:"This field must be a valid color in hexadecimal format"}}})}validate(e,s,t){return typeof e!="string"?this.replyFail(s,t):/^#(?:(?:[0-9a-f]{3}){1,2}|(?:[0-9a-f]{4}){1,2})$/i.test(e)?this.replySuccess(s,t):this.replyFail(s,t)}}class T extends h{constructor(){super(...arguments);l(this,"name","integer");l(this,"strings",{fail:{withLabel:{default:"The field :label must be an integer number","{}":"The field {label} must be an integer number"},withoutLabel:{default:"This field must be an integer number"}}})}validate(e,s,t){return typeof e=="number"&&Number.isInteger(e)?this.replySuccess(s,t):typeof e=="string"&&/^[0-9.]+$/.test(e)&&Number.isInteger(Number(e))?this.replySuccess(s,t):this.replyFail(s,t)}}class v extends h{constructor(){super(...arguments);l(this,"name","max");l(this,"strings",{fail:{withLabel:{default:"The field :label cannot be greater than :value","{}":"The field {label} cannot be greater than {value}"},withoutLabel:{default:"This field cannot be greater than :value","{}":"This field cannot be greater than {value}"}}})}validate(e,s,t,a){return e<=s.max?this.replySuccess(t,a):this.replyFail(t,a,{value:s.max.toString()})}callback(e,s,t,a){if(s[0]===void 0)throw new Error("A maximum value must be provided");if(typeof e!="number"&&typeof e!="string")return this.replyFail(t,a);const i=Number(e);return isNaN(i)?this.replyFail(t,a):this.validate(i,{max:Number(s[0])},t,a)}}class S extends h{constructor(){super(...arguments);l(this,"name","max_chars");l(this,"strings",{fail:{withLabel:{default:"The field :label cannot be more than :value characters long","{}":"The field {label} cannot be more than {value} characters long"},withoutLabel:{default:"This field cannot be more than :value characters long","{}":"This field cannot be more than {value} characters long"}}})}validate(e,s,t,a){return e.length<=s.max?this.replySuccess(t,a):this.replyFail(t,a,{value:s.max.toString()})}callback(e,s,t,a){if(s[0]===void 0)throw new Error("A maximum value must be provided");if(e==null)return this.replySuccess(t,a);if(typeof e=="boolean")return this.replyFail(t,a);const i=typeof e=="number"?e.toString():e;return this.validate(i,{max:parseInt(s[0])},t,a)}}class L extends h{constructor(){super(...arguments);l(this,"name","min");l(this,"strings",{fail:{withLabel:{default:"The field :label cannot be smaller than :value","{}":"The field {label} cannot be smaller than {value}"},withoutLabel:{default:"This field cannot be smaller than :value","{}":"This field cannot be smaller than {value}"}}})}validate(e,s,t,a){return e>=s.min?this.replySuccess(t,a):this.replyFail(t,a,{value:s.min.toString()})}callback(e,s,t,a){if(s[0]===void 0)throw new Error("A minimum value must be provided");if(typeof e!="number"&&typeof e!="string")return this.replyFail(t,a);const i=Number(e);return isNaN(i)?this.replyFail(t,a):this.validate(i,{min:Number(s[0])},t,a)}}class F extends h{constructor(){super(...arguments);l(this,"name","min_chars");l(this,"strings",{fail:{withLabel:{default:"The field :label must be at least :value characters long","{}":"The field {label} must be at least {value} characters long"},withoutLabel:{default:"This field must be at least :value characters long","{}":"This field must be at least {value} characters long"}}})}validate(e,s,t,a){return e.length>=s.min?this.replySuccess(t,a):this.replyFail(t,a,{value:s.min.toString()})}callback(e,s,t,a){if(s[0]===void 0)throw new Error("A minimum value must be provided");if(typeof e=="boolean")return this.replyFail(t,a);let i="";return typeof e=="number"?i=e.toString():typeof e=="string"&&(i=e),this.validate(i,{min:parseInt(s[0])},t,a)}}class N extends h{constructor(){super(...arguments);l(this,"name","not_equal");l(this,"strings",{fail:{withLabel:{default:"The field :label cannot be equal to :value","{}":"The field {label} cannot be equal to {value}"},withoutLabel:{default:"This field cannot be equal to :value","{}":"This field cannot be equal to {value}"}}})}validate(e,s,t,a){for(const i of s.comparison)if(i===e)return this.replyFail(t,a,{value:e});return this.replySuccess(t,a)}callback(e,s,t,a){if(s[0]===void 0)throw new Error("A comparison value must be provided");const i=typeof e=="string"?e:String(e);return this.validate(i,{comparison:s},t,a)}}class E extends h{constructor(){super(...arguments);l(this,"name","not_regex");l(this,"strings",{fail:{withLabel:{default:"The field :label does not match","{}":"The field {label} does not match"},withoutLabel:{default:"This field does not match"}}})}validate(e,s,t,a){return new RegExp(s.pattern,s.flags).test(e)?this.replyFail(t,a):this.replySuccess(t,a)}callback(e,s,t,a){if(s[0]===void 0)throw new Error("A regex must be provided");let i="";return typeof e=="number"?i=e.toString():typeof e=="string"&&(i=e),this.validate(i,{pattern:s[0],flags:s[1]},t,a)}}class R extends h{constructor(){super(...arguments);l(this,"name","numeric");l(this,"strings",{fail:{withLabel:{default:"The field :label must be a number","{}":"The field {label} must be a number"},withoutLabel:{default:"This field must be a number"}}})}validate(e,s,t){return typeof e=="number"?this.replySuccess(s,t):/^[0-9.]+$/.test(String(e))&&!isNaN(Number(e))?this.replySuccess(s,t):this.replyFail(s,t)}}class V extends h{constructor(){super(...arguments);l(this,"name","regex");l(this,"strings",{fail:{withLabel:{default:"The field :label does not match","{}":"The field {label} does not match"},withoutLabel:{default:"This field does not match"}}})}validate(e,s,t,a){return new RegExp(s.pattern,s.flags).test(e)?this.replySuccess(t,a):this.replyFail(t,a)}callback(e,s,t,a){if(s[0]===void 0)throw new Error("A regex must be provided");let i="";return typeof e=="number"?i=e.toString():typeof e=="string"&&(i=e),this.validate(i,{pattern:s[0],flags:s[1]},t,a)}}class q extends h{constructor(){super(...arguments);l(this,"name","required");l(this,"strings",{fail:{withLabel:{default:"The field :label is required","{}":"The field {label} is required"},withoutLabel:{default:"This field is required"}}})}validate(e,s,t){return e==null?this.replyFail(s,t):typeof e=="boolean"?this.replySuccess(s,t):typeof e=="number"?isNaN(e)?this.replyFail(s,t):this.replySuccess(s,t):e.trim().length>0?this.replySuccess(s,t):this.replyFail(s,t)}}class _{constructor(r){l(this,"rules",{alpha:new b,alpha_dash:new p,alpha_num:new y,equal:new w,hex_color:new x,integer:new T,regex:new V,required:new q,max:new v,max_chars:new S,min:new L,min_chars:new F,not_equal:new N,not_regex:new E,numeric:new R});l(this,"interpolation",":");l(this,"reply",new f);if(r!=null&&r.customRules)for(const e of r.customRules)this.addRule(e);r!=null&&r.interpolation&&(this.interpolation=r.interpolation)}addRule(r){this.rules[r.name]=r}hasErrors(){return this.reply.hasErrors}getErrorMessages(){return this.reply.errorMessages}getReplies(){return this.reply.replies}validateSingle(r,e,s,t){return this.rules[e]?this.rules[e].callback?this.rules[e].callback(r,s,t,this.interpolation):this.rules[e].validate(r,t,this.interpolation):new c(e,!0,new d("Validation rule doesn't exist"))}validate(r,e,s){this.reply.clear();for(const t of e){const a=t.split(":");let i=[];typeof a[1]<"u"&&(i=a[1].split(",")),this.reply.push(this.validateSingle(r,a[0],i,s))}return!this.reply.hasErrors}}exports.Message=d;exports.RuleReply=c;exports.Validation=_;exports.ValidationReply=f;exports.ValidationRule=h;
